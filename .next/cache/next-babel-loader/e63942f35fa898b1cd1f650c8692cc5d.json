{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useEffect, useState } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { apiLocation } from '../config.json';\nimport { Actions } from '../defs/contentManager';\nlet undoStack = [];\nexport function useContentManager(root) {\n  const {\n    0: loadedContent,\n    1: setLoadedContent\n  } = useState([root]);\n  const {\n    0: actions,\n    1: setActions\n  } = useState([]);\n  useEffect(() => {\n    for (let subject of root.children) {\n      loadContent(subject);\n    }\n  }, []);\n\n  function addAction(action, clearUndoStack) {\n    setActions(prevState => [...prevState, action]);\n    if (clearUndoStack) undoStack = [];\n  }\n\n  function removeAction(idx) {\n    let actionsCopy = actions.slice(); // Clone array\n\n    actionsCopy.splice(idx, 1);\n    setActions(actionsCopy);\n  }\n\n  function undo() {\n    let action = actions[actions.length - 1];\n\n    switch (action.type) {\n      case Actions.ADD:\n        {\n          removeObject(action.object, action.to, false);\n          break;\n        }\n\n      case Actions.REMOVE:\n        {\n          addObject(action.object, action.from, action.object.prevSibling, false);\n          break;\n        }\n\n      case Actions.MODIFY:\n        {\n          modifyObject(action.to, action.from, false);\n          break;\n        }\n\n      case Actions.MOVE_UP:\n        {\n          moveObjectDown(action.object, false);\n          break;\n        }\n\n      case Actions.MOVE_DOWN:\n        {\n          moveObjectUp(action.object, false);\n          break;\n        }\n\n      default:\n        return;\n    }\n\n    removeAction(actions.length - 1);\n    undoStack.push(actions[actions.length - 1]);\n    removeAction(actions.length - 1);\n  }\n\n  function redo() {\n    let action = undoStack.pop();\n\n    switch (action.type) {\n      case Actions.ADD:\n        {\n          addObject(action.object, action.to, action.after, false);\n          break;\n        }\n\n      case Actions.REMOVE:\n        {\n          removeObject(action.object, action.from, false);\n          break;\n        }\n\n      case Actions.MODIFY:\n        {\n          modifyObject(action.from, action.to, false);\n          break;\n        }\n\n      case Actions.MOVE_UP:\n        {\n          moveObjectUp(action.object, false);\n          break;\n        }\n\n      case Actions.MOVE_DOWN:\n        {\n          moveObjectDown(action.object, false);\n          break;\n        }\n    }\n  }\n\n  function addObject(object, to, after, clearUndoStack = true) {\n    let completeObject;\n\n    if ('prevSibling' in object) {\n      completeObject = object;\n    } else {\n      var _loadedContent$find;\n\n      let prevSibling = after;\n      let nextSibling = (_loadedContent$find = loadedContent.find(({\n        uuid\n      }) => uuid === after)) === null || _loadedContent$find === void 0 ? void 0 : _loadedContent$find.nextSibling;\n      if (typeof nextSibling === 'undefined') nextSibling = '0';\n      let parent = to;\n      completeObject = _objectSpread(_objectSpread({}, object), {}, {\n        prevSibling,\n        nextSibling,\n        parent\n      });\n    }\n\n    addAction({\n      uuid: uuidv4(),\n      type: Actions.ADD,\n      object: completeObject,\n      to,\n      after\n    }, clearUndoStack);\n    let loadedContentCopy = loadedContent.slice();\n    loadedContentCopy.push(completeObject);\n    let parent = loadedContentCopy.find(content => content.uuid === to);\n\n    if (completeObject.prevSibling !== '0') {\n      loadedContentCopy.find(({\n        uuid\n      }) => uuid === completeObject.prevSibling).nextSibling = object.uuid;\n    }\n\n    if (completeObject.nextSibling !== '0') {\n      loadedContentCopy.find(({\n        uuid\n      }) => uuid === completeObject.nextSibling).prevSibling = object.uuid;\n    }\n\n    let idx;\n\n    if (after === '0') {\n      idx = 0;\n    } else {\n      idx = parent.children.findIndex(uuid => uuid === after) + 1;\n    }\n\n    parent.children.splice(idx, 0, object.uuid);\n    setLoadedContent(loadedContentCopy);\n  }\n\n  function removeObject(object, from, clearUndoStack = true) {\n    addAction({\n      uuid: uuidv4(),\n      type: Actions.REMOVE,\n      object,\n      from\n    }, clearUndoStack);\n    let loadedContentCopy = loadedContent.slice();\n    let idx = loadedContentCopy.findIndex(content => content.uuid === object.uuid);\n    loadedContentCopy.splice(idx, 1);\n    let parent = loadedContentCopy.find(content => content.uuid === from);\n    if (parent.type === 'article') throw new Error('Invalid parent.');\n    idx = parent.children.findIndex(uuid => uuid === object.uuid);\n    parent.children.splice(idx, 1);\n\n    if (object.prevSibling !== '0') {\n      let prevSibling = loadedContentCopy.find(({\n        uuid\n      }) => uuid === object.prevSibling);\n      prevSibling.nextSibling = object.nextSibling;\n    }\n\n    if (object.nextSibling !== '0') {\n      let nextSibling = loadedContentCopy.find(({\n        uuid\n      }) => uuid === object.nextSibling);\n      nextSibling.prevSibling = object.prevSibling;\n    }\n\n    setLoadedContent(loadedContentCopy);\n  }\n\n  function modifyObject(from, to, clearUndoStack = true) {\n    addAction({\n      uuid: uuidv4(),\n      type: Actions.MODIFY,\n      from,\n      to\n    }, clearUndoStack);\n    let loadedContentCopy = loadedContent.slice();\n    let idx = loadedContentCopy.findIndex(content => content.uuid === from.uuid);\n    loadedContentCopy[idx] = to;\n    setLoadedContent(loadedContentCopy);\n  }\n\n  function moveObjectUp(object, clearUndoStack = true) {\n    var _loadedContent$find2;\n\n    let item = loadedContent.find(({\n      uuid\n    }) => uuid === object.uuid);\n    if (item.prevSibling === '0') return; // Soft fail\n\n    addAction({\n      uuid: uuidv4(),\n      type: Actions.MOVE_UP,\n      object\n    }, clearUndoStack);\n    let parent = loadedContent.find(({\n      uuid\n    }) => uuid === item.parent);\n    let idx = parent.children.findIndex(child => child === object.uuid);\n    let temp = parent.children[idx];\n    parent.children[idx] = parent.children[idx - 1];\n    parent.children[idx - 1] = temp; // Update sibling two items above\n\n    let prevItem = loadedContent.find(({\n      uuid\n    }) => uuid === item.prevSibling);\n    if (prevItem.prevSibling !== '0') loadedContent.find(({\n      uuid\n    }) => uuid === prevItem.prevSibling).nextSibling = object.uuid; // Update previous and next siblings\n\n    if (item.nextSibling !== '0') loadedContent.find(({\n      uuid\n    }) => uuid === item.nextSibling).prevSibling = item.prevSibling;\n    prevItem.nextSibling = item.nextSibling;\n    prevItem.prevSibling = object.uuid; // Update item itself\n\n    item.nextSibling = item.prevSibling;\n    item.prevSibling = ((_loadedContent$find2 = loadedContent.find(({\n      uuid\n    }) => uuid === parent.children[idx - 2])) === null || _loadedContent$find2 === void 0 ? void 0 : _loadedContent$find2.uuid) || '0';\n    setLoadedContent(loadedContent.slice());\n  }\n\n  function moveObjectDown(object, clearUndoStack = true) {\n    var _loadedContent$find3;\n\n    let item = loadedContent.find(({\n      uuid: testUuid\n    }) => testUuid === object.uuid);\n    if (item.nextSibling === '0') return; // Soft fail\n\n    addAction({\n      uuid: uuidv4(),\n      type: Actions.MOVE_DOWN,\n      object\n    }, clearUndoStack);\n    let parent = loadedContent.find(({\n      uuid\n    }) => uuid === item.parent);\n    let idx = parent.children.findIndex(child => child === object.uuid);\n    let temp = parent.children[idx];\n    parent.children[idx] = parent.children[idx + 1];\n    parent.children[idx + 1] = temp; // Update sibling two items below\n\n    let nextItem = loadedContent.find(({\n      uuid\n    }) => uuid === item.nextSibling);\n    if (nextItem.nextSibling !== '0') loadedContent.find(({\n      uuid\n    }) => uuid === nextItem.nextSibling).prevSibling = object.uuid; // Update previous and next siblings\n\n    if (item.prevSibling !== '0') loadedContent.find(({\n      uuid\n    }) => uuid === item.prevSibling).nextSibling = item.nextSibling;\n    nextItem.prevSibling = item.prevSibling;\n    nextItem.nextSibling = object.uuid; // Update item itself\n\n    item.prevSibling = item.nextSibling;\n    item.nextSibling = ((_loadedContent$find3 = loadedContent.find(({\n      uuid\n    }) => uuid === parent.children[idx + 2])) === null || _loadedContent$find3 === void 0 ? void 0 : _loadedContent$find3.uuid) || '0';\n    setLoadedContent(loadedContent.slice());\n  }\n\n  async function loadContent(uuid) {\n    if (loadedContent.findIndex(({\n      uuid: testUuid\n    }) => testUuid === uuid) !== -1) return;\n    let loadedContentCopy = loadedContent.slice();\n    loadedContentCopy.push(await (await fetch(`${apiLocation}/content/${uuid}`)).json());\n    setLoadedContent(loadedContentCopy);\n  }\n\n  return {\n    undoStack,\n    actions,\n    loadedContent,\n    undo,\n    redo,\n    addObject,\n    removeObject,\n    modifyObject,\n    moveObjectUp,\n    moveObjectDown,\n    loadContent\n  };\n}","map":{"version":3,"sources":["/Users/brandontsang/projects/slate/src/hooks/contentManager.ts"],"names":["useEffect","useState","v4","uuidv4","apiLocation","Actions","undoStack","useContentManager","root","loadedContent","setLoadedContent","actions","setActions","subject","children","loadContent","addAction","action","clearUndoStack","prevState","removeAction","idx","actionsCopy","slice","splice","undo","length","type","ADD","removeObject","object","to","REMOVE","addObject","from","prevSibling","MODIFY","modifyObject","MOVE_UP","moveObjectDown","MOVE_DOWN","moveObjectUp","push","redo","pop","after","completeObject","nextSibling","find","uuid","parent","loadedContentCopy","content","findIndex","Error","item","child","temp","prevItem","testUuid","nextItem","fetch","json"],"mappings":"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","sourcesContent":["import {useEffect, useState} from 'react';\nimport {v4 as uuidv4} from 'uuid';\n\nimport {apiLocation} from '../config.json';\nimport {Action, Actions} from '../defs/contentManager';\nimport {\n    Content,\n    IncompleteContent,\n    Root,\n    Subject,\n    Folder\n} from '../defs/content';\n\nlet undoStack = [] as Action<Content>[];\n\nexport function useContentManager(root: Root) {\n    const [loadedContent, setLoadedContent] = useState([root] as Array<\n        Content | Root\n    >);\n    const [actions, setActions] = useState([] as Action<Content>[]);\n\n    useEffect(() => {\n        for (let subject of root.children) {\n            loadContent(subject);\n        }\n    }, []);\n\n    function addAction<T extends Content>(\n        action: Action<T>,\n        clearUndoStack: boolean\n    ) {\n        setActions((prevState) => [...prevState, action]);\n        if (clearUndoStack) undoStack = [];\n    }\n\n    function removeAction(idx: number) {\n        let actionsCopy = actions.slice(); // Clone array\n        actionsCopy.splice(idx, 1);\n        setActions(actionsCopy);\n    }\n\n    function undo() {\n        let action = actions[actions.length - 1];\n\n        switch (action.type) {\n            case Actions.ADD: {\n                removeObject(action.object, action.to, false);\n                break;\n            }\n            case Actions.REMOVE: {\n                addObject(\n                    action.object,\n                    action.from,\n                    action.object.prevSibling,\n                    false\n                );\n                break;\n            }\n            case Actions.MODIFY: {\n                modifyObject(action.to, action.from, false);\n                break;\n            }\n            case Actions.MOVE_UP: {\n                moveObjectDown(action.object, false);\n                break;\n            }\n            case Actions.MOVE_DOWN: {\n                moveObjectUp(action.object, false);\n                break;\n            }\n            default:\n                return;\n        }\n\n        removeAction(actions.length - 1);\n\n        undoStack.push(actions[actions.length - 1]);\n        removeAction(actions.length - 1);\n    }\n\n    function redo() {\n        let action = undoStack.pop();\n\n        switch (action.type) {\n            case Actions.ADD: {\n                addObject(action.object, action.to, action.after, false);\n                break;\n            }\n            case Actions.REMOVE: {\n                removeObject(action.object, action.from, false);\n                break;\n            }\n            case Actions.MODIFY: {\n                modifyObject(action.from, action.to, false);\n                break;\n            }\n            case Actions.MOVE_UP: {\n                moveObjectUp(action.object, false);\n                break;\n            }\n            case Actions.MOVE_DOWN: {\n                moveObjectDown(action.object, false);\n                break;\n            }\n        }\n    }\n\n    function addObject(\n        object: IncompleteContent | Content,\n        to: string,\n        after: string,\n        clearUndoStack = true\n    ) {\n        let completeObject: Content;\n        if ('prevSibling' in object) {\n            completeObject = object;\n        } else {\n            let prevSibling = after;\n            let nextSibling = loadedContent.find(({uuid}) => uuid === after)\n                ?.nextSibling;\n            if (typeof nextSibling === 'undefined') nextSibling = '0';\n            let parent = to;\n            completeObject = {...object, prevSibling, nextSibling, parent};\n        }\n\n        addAction(\n            {\n                uuid: uuidv4(),\n                type: Actions.ADD,\n                object: completeObject,\n                to,\n                after\n            },\n            clearUndoStack\n        );\n\n        let loadedContentCopy = loadedContent.slice();\n        loadedContentCopy.push(completeObject);\n\n        let parent = loadedContentCopy.find(\n            (content) => content.uuid === to\n        ) as Root | Subject | Folder;\n\n        if (completeObject.prevSibling !== '0') {\n            loadedContentCopy.find(\n                ({uuid}) => uuid === completeObject.prevSibling\n            ).nextSibling = object.uuid;\n        }\n        if (completeObject.nextSibling !== '0') {\n            loadedContentCopy.find(\n                ({uuid}) => uuid === completeObject.nextSibling\n            ).prevSibling = object.uuid;\n        }\n\n        let idx: number;\n        if (after === '0') {\n            idx = 0;\n        } else {\n            idx = parent.children.findIndex((uuid) => uuid === after) + 1;\n        }\n\n        parent.children.splice(idx, 0, object.uuid);\n\n        setLoadedContent(loadedContentCopy);\n    }\n\n    function removeObject(\n        object: Content,\n        from: string,\n        clearUndoStack = true\n    ) {\n        addAction(\n            {uuid: uuidv4(), type: Actions.REMOVE, object, from},\n            clearUndoStack\n        );\n\n        let loadedContentCopy = loadedContent.slice();\n        let idx = loadedContentCopy.findIndex(\n            (content) => content.uuid === object.uuid\n        );\n        loadedContentCopy.splice(idx, 1);\n\n        let parent = loadedContentCopy.find((content) => content.uuid === from);\n        if (parent.type === 'article') throw new Error('Invalid parent.');\n        idx = parent.children.findIndex((uuid) => uuid === object.uuid);\n        parent.children.splice(idx, 1);\n\n        if (object.prevSibling !== '0') {\n            let prevSibling = loadedContentCopy.find(\n                ({uuid}) => uuid === object.prevSibling\n            );\n            prevSibling.nextSibling = object.nextSibling;\n        }\n\n        if (object.nextSibling !== '0') {\n            let nextSibling = loadedContentCopy.find(\n                ({uuid}) => uuid === object.nextSibling\n            );\n            nextSibling.prevSibling = object.prevSibling;\n        }\n\n        setLoadedContent(loadedContentCopy);\n    }\n\n    function modifyObject<T extends Content>(\n        from: T,\n        to: T,\n        clearUndoStack = true\n    ) {\n        addAction(\n            {\n                uuid: uuidv4(),\n                type: Actions.MODIFY,\n                from,\n                to\n            },\n            clearUndoStack\n        );\n\n        let loadedContentCopy = loadedContent.slice();\n        let idx = loadedContentCopy.findIndex(\n            (content) => content.uuid === from.uuid\n        );\n        loadedContentCopy[idx] = to;\n\n        setLoadedContent(loadedContentCopy);\n    }\n\n    function moveObjectUp(object: Content, clearUndoStack = true) {\n        let item = loadedContent.find(({uuid}) => uuid === object.uuid);\n        if (item.prevSibling === '0') return; // Soft fail\n\n        addAction(\n            {uuid: uuidv4(), type: Actions.MOVE_UP, object},\n            clearUndoStack\n        );\n\n        let parent = loadedContent.find(({uuid}) => uuid === item.parent) as\n            | Root\n            | Subject\n            | Folder;\n        let idx = parent.children.findIndex((child) => child === object.uuid);\n        let temp = parent.children[idx];\n        parent.children[idx] = parent.children[idx - 1];\n        parent.children[idx - 1] = temp;\n\n        // Update sibling two items above\n        let prevItem = loadedContent.find(\n            ({uuid}) => uuid === item.prevSibling\n        );\n        if (prevItem.prevSibling !== '0')\n            loadedContent.find(\n                ({uuid}) => uuid === prevItem.prevSibling\n            ).nextSibling = object.uuid;\n\n        // Update previous and next siblings\n        if (item.nextSibling !== '0')\n            loadedContent.find(\n                ({uuid}) => uuid === item.nextSibling\n            ).prevSibling = item.prevSibling;\n\n        prevItem.nextSibling = item.nextSibling;\n        prevItem.prevSibling = object.uuid;\n\n        // Update item itself\n        item.nextSibling = item.prevSibling;\n        item.prevSibling =\n            loadedContent.find(({uuid}) => uuid === parent.children[idx - 2])\n                ?.uuid || '0';\n\n        setLoadedContent(loadedContent.slice());\n    }\n\n    function moveObjectDown(object: Content, clearUndoStack = true) {\n        let item = loadedContent.find(\n            ({uuid: testUuid}) => testUuid === object.uuid\n        );\n        if (item.nextSibling === '0') return; // Soft fail\n\n        addAction(\n            {uuid: uuidv4(), type: Actions.MOVE_DOWN, object},\n            clearUndoStack\n        );\n\n        let parent = loadedContent.find(({uuid}) => uuid === item.parent) as\n            | Root\n            | Subject\n            | Folder;\n        let idx = parent.children.findIndex((child) => child === object.uuid);\n        let temp = parent.children[idx];\n        parent.children[idx] = parent.children[idx + 1];\n        parent.children[idx + 1] = temp;\n\n        // Update sibling two items below\n        let nextItem = loadedContent.find(\n            ({uuid}) => uuid === item.nextSibling\n        );\n        if (nextItem.nextSibling !== '0')\n            loadedContent.find(\n                ({uuid}) => uuid === nextItem.nextSibling\n            ).prevSibling = object.uuid;\n\n        // Update previous and next siblings\n        if (item.prevSibling !== '0')\n            loadedContent.find(\n                ({uuid}) => uuid === item.prevSibling\n            ).nextSibling = item.nextSibling;\n\n        nextItem.prevSibling = item.prevSibling;\n        nextItem.nextSibling = object.uuid;\n\n        // Update item itself\n        item.prevSibling = item.nextSibling;\n        item.nextSibling =\n            loadedContent.find(({uuid}) => uuid === parent.children[idx + 2])\n                ?.uuid || '0';\n\n        setLoadedContent(loadedContent.slice());\n    }\n\n    async function loadContent(uuid: string) {\n        if (\n            loadedContent.findIndex(({uuid: testUuid}) => testUuid === uuid) !==\n            -1\n        )\n            return;\n\n        let loadedContentCopy = loadedContent.slice();\n        loadedContentCopy.push(\n            await (await fetch(`${apiLocation}/content/${uuid}`)).json()\n        );\n        setLoadedContent(loadedContentCopy);\n    }\n\n    return {\n        undoStack,\n        actions,\n        loadedContent,\n        undo,\n        redo,\n        addObject,\n        removeObject,\n        modifyObject,\n        moveObjectUp,\n        moveObjectDown,\n        loadContent\n    };\n}\n"]},"metadata":{},"sourceType":"module"}